const GEMINI_API_KEY = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

function doPost(e) {
  try {
    // A lógica principal permanece a mesma
    const requestData = JSON.parse(e.postData.contents);
    if (requestData && requestData.action === 'processText' && requestData.text) {
      const userInput = requestData.text;
      const gemResponse = processWithGemini(userInput);
      executeGoogleAction(gemResponse.google_action);
      
      const jsonResponse = JSON.stringify({ success: true, gemResponse: gemResponse });

      // Retornamos a resposta da forma mais simples possível
      return ContentService
        .createTextOutput(jsonResponse)
        .setMimeType(ContentService.MimeType.JSON);

    } else {
      throw new Error("Ação ou texto inválido na requisição.");
    }
  } catch (error) {
     Logger.log("Erro em doPost: " + error.toString());
     const errorResponse = JSON.stringify({ success: false, error: error.toString() });
     return ContentService
      .createTextOutput(errorResponse)
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// As funções abaixo (processWithGemini, executeGoogleAction) permanecem as mesmas
function processWithGemini(userInput) {
  if (!GEMINI_API_KEY) {
    throw new Error("Erro: GEMINI_API_KEY não configurada nas propriedades do script.");
  }
  const today = new Date().toLocaleDateString('pt-BR', { year: 'numeric', month: '2-digit', day: '2-digit' });
  const promptText = `
    Você é o 'Processador e Dispatcher de Ações' do sistema de organização pessoal MindMate.
    Sua única função é analisar o texto do usuário e traduzi-lo para um objeto JSON estruturado.
    Você deve ser estritamente técnico e retornar apenas o JSON.
    **Formato de Saída Obrigatório (JSON):**
    {
      "classificacao": {
        "nome_atividade": "string",
        "tipo": "string",
        "tags": "string (ex: '#mod_work #type_fixed #emo_foco')",
        "data_agendada": "string (formato: yyyy-MM-dd) | null",
        "hora_agendada": "string (formato: HH:mm) | null",
        "subtarefas": [
          {"texto": "string", "concluida": false}
        ]
      },
      "google_action": {
        "service": "string (GoogleCalendar|GoogleTasks|GoogleDocs|GoogleKeep)",
        "payload": {}
      }
    }

    ---
    **Biblioteca de Tags & Glossário de Tipos Oficiais:**
    * **tipo (Escolha UMA):** diario, tarefa, projeto, planner, nota_ideia.
    * **tags (Use UMA ou MAIS):**
        * **Módulos (#mod_):** #mod_work, #mod_family, #mod_mind, #mod_body, #mod_finance, #mod_purpose, #mod_bridge.
        * **Tipo de Ação (#type_):** #type_fixed, #type_project, #type_habit, #type_recurring, #type_personal_ritual.
        * **Emoções (#emo_):** Inferir de palavras como "feliz" (#emo_alegria), "ansioso" (#emo_ansiedade), etc.
    ---
    **Regras de Ação e Payload:**
    1.  Se 'tipo' for 'planner': service: "GoogleCalendar", payload: { "summary": "[nome_atividade]", "description": "[tags]", "start": "[data_agendada]T[hora_agendada]", "end": "[data_agendada]T[hora_agendada + 1 hora]" }
    2.  Se 'tipo' for 'tarefa': service: "GoogleTasks", payload: { "title": "[nome_atividade]", "notes": "[tags]", "due": "[data_agendada]T00:00:00.000Z" }
    3.  Se 'tipo' for 'projeto': service: "GoogleDocs", payload: { "title": "Projeto: [nome_atividade]", "body": "Tags: [tags]\\n\\n**Subtarefas:**\\n- [subtarefa1]\\n- [subtarefa2]" }
    4.  Se 'tipo' for 'diario' ou 'nota_ideia': service: "GoogleKeep", payload: { "title": "[nome_atividade]", "text": "Tags: [tags]\\n\\n[conteúdo completo do usuário]" }
 
    5.  A data de hoje é ${today}. Use o ano atual para as datas.
    Converta datas relativas como "amanhã" ou "próxima sexta" para o formato yyyy-MM-dd.
    ---
    **Texto do Usuário para Processar:**
    ${userInput}
  `;
  const requestBody = { contents: [{ parts: [{ text: promptText }] }] };
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(requestBody),
    muteHttpExceptions: true
  };
  const url = `https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
  
  const response = UrlFetchApp.fetch(url, options);
  const rawGeminiResponseText = response.getContentText();
  Logger.log("Resposta do Gemini: " + rawGeminiResponseText);
  const apiResponse = JSON.parse(rawGeminiResponseText);
  if (apiResponse.error) {
    throw new Error("Erro da API Gemini: " + apiResponse.error.message);
  }

  const textPart = apiResponse.candidates[0].content.parts[0].text;
  const result = JSON.parse(textPart.replace(/```json\n?|\n```/g, ''));
  return result;
}

function executeGoogleAction(googleAction) {
  Logger.log(`Executando ação para o serviço: ${googleAction.service}`);
  switch(googleAction.service) {
    case 'GoogleCalendar':
      const calendar = CalendarApp.getDefaultCalendar();
      const start = new Date(googleAction.payload.start);
      const end = new Date(googleAction.payload.end);
      calendar.createEvent(googleAction.payload.summary, start, end, {description: googleAction.payload.description});
      Logger.log("Evento criado no Google Calendar.");
      break;
    case 'GoogleTasks':
      const task = Tasks.newTask();
      task.setTitle(googleAction.payload.title);
      task.setNotes(googleAction.payload.notes);
      if (googleAction.payload.due) {
        task.setDue(googleAction.payload.due);
      }
      Tasks.Tasks.insert(task, '@default');
      Logger.log("Tarefa criada no Google Tasks.");
      break;
    case 'GoogleDocs':
      const doc = DocumentApp.create(googleAction.payload.title);
      doc.getBody().setText(googleAction.payload.body);
      Logger.log(`Documento '${doc.getName()}' criado no Google Docs.`);
      break;
    case 'GoogleKeep':
      Logger.log("Ação para Google Keep. Como não há API, simulando criação de nota.");
      const keepNoteTitle = `Nota/Ideia do MindMate: ${googleAction.payload.title}`;
      const keepNoteBody = `Uma nova entrada foi capturada pelo MindMate:\n\n${googleAction.payload.text}`;
      MailApp.sendEmail(Session.getActiveUser().getEmail(), keepNoteTitle, keepNoteBody);
      Logger.log("Nota enviada por e-mail como fallback para o Google Keep.");
      break;
    default:
      Logger.log(`Serviço desconhecido: ${googleAction.service}. Nenhuma ação executada.`);
      break;
  }
}
